#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     mFrontLeft,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mBackLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     mIntake,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     mLiftR,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     mBackRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     mFrontRight,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     mKnocker,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     mLiftL,        tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    sFloodGate,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_2,    sIR,                  tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    sTongue,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

const int LIFT_MIN = 0;
const int LIFT_MAX = 7700;

/**
* Set motor powers for yolonomic drive
*
* left and right: the tank drive values from -100 to 100.
* strafe: the movement left and right from -100 to 100.
* rotation: the rotation from -100 to 100.
*/
void yolodrive(int left, int right, int strafe, int rotation)
{
	int pFL = left - strafe + rotation;
	int pBL = left + strafe + rotation;
	int pFR = right + strafe - rotation;
	int pBR = right - strafe - rotation;

	float biggest = abs(pFL);
	if (abs(pBL) > biggest) biggest = abs(pBL);
	if (abs(pFR) > biggest) biggest = abs(pFR);
	if (abs(pBR) > biggest) biggest = abs(pBR);

	float scale = 1;
	if (biggest > 100) {
		scale = 100.0 / biggest;
	}

	motor[mFrontLeft] = (int) (scale * pFL);
	motor[mBackLeft] = (int) (scale * pBL);
	motor[mFrontRight] = (int) (scale * pFR);
	motor[mBackRight] = (int) (scale * pBR);
}

/**
* Reset motor powers back to zero
*/
void resetDrive()
{
	motor[mFrontLeft] = motor[mBackLeft] = motor[mFrontRight] = motor[mBackRight] = 0;
}

int threshold(int raw)
{
	if (abs(raw) < 60) {
		return 0;
		} else {
		return raw * 100 / 128;
	}
}

void gate(){
	if(joy1Btn(7)){
		servo[sFloodGate] = 5;
	}
	else if(joy1Btn(5)){
		servo[sFloodGate] = 250;
	}
	else{
		servo[sFloodGate] = 127;
	}

}

void tongue(){
	if (joy2Btn(2)) {
		servo[sTongue] = 95;
	} else {
		servo[sTongue] = 200;
	}
}

void intake(){
	if(joy2Btn(4)){
		motor[mIntake] = 100;
	}
	else if(joy2Btn(1)){
		motor[mIntake] = 0;
	}
}

void knocker(){
	if (joystick.joy1_TopHat == 2) {
		motor[mKnocker] = 25;
	} else if (joystick.joy1_TopHat == 6) {
		motor[mKnocker] = -25;
	} else {
		motor[mKnocker] = 0;
	}
}

void lift()
{
	int power = threshold(joystick.joy2_y1);

	if (joy2Btn(11)) { // press left joystick
		nMotorEncoder[mLiftR] = 0;
	} else {
		// Go slower when going down
		if (power < 0) {
			power = power * 40 / 100;
		}

		bool tooLow = power < 0 && nMotorEncoder[mLiftR] <= LIFT_MIN;
		bool tooHigh = power > 0 && nMotorEncoder[mLiftR] >= LIFT_MAX;
		if (tooLow || tooHigh) {
			power = 0;
		}
	}

	if (joy2Btn(5)) { // left top shoulder
		power /= 3;
	}

	motor[mLiftL] = motor[mLiftR] = power;
}

task main(){
	while (true){
		getJoystickSettings(joystick);

		yolodrive(
			threshold(joystick.joy1_y1),
			threshold(joystick.joy1_y2),
			threshold(joystick.joy1_x1),
			threshold(joystick.joy1_x2));

		lift();
		tongue();
		intake();
		gate();
		knocker();
	}
}
