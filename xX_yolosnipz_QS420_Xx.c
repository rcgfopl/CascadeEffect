#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     mFrontLeft,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mBackLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     mIntake,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     mLiftR,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     mBackRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     mFrontRight,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     mKnocker,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     mLiftL,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    sFloodGate,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_2,    sIR,                  tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    sTongue,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"


/**
* Set motor powers for yolonomic drive
*
* left and right: the tank drive values from -100 to 100.
* strafe: the movement left and right from -100 to 100.
* rotation: the rotation from -100 to 100.
*/
void yolodrive(int left, int right, int strafe, int rotation)
{
	int pFL = left - strafe + rotation;
	int pBL = left + strafe + rotation;
	int pFR = right + strafe - rotation;
	int pBR = right - strafe - rotation;

	float biggest = abs(pFL);
	if (abs(pBL) > biggest) biggest = abs(pBL);
	if (abs(pFR) > biggest) biggest = abs(pFR);
	if (abs(pBR) > biggest) biggest = abs(pBR);

	float scale = 1;
	if (biggest > 100) {
		scale = 100.0 / biggest;
	}

	motor[mFrontLeft] = (int) (scale * pFL);
	motor[mBackLeft] = (int) (scale * pBL);
	motor[mFrontRight] = (int) (scale * pFR);
	motor[mBackRight] = (int) (scale * pBR);
}

void tankdrive(){
	motor[mFrontLeft] = joystick.joy1_y1;
	motor[mBackLeft] = joystick.joy1_y1;
	motor[mFrontRight] = joystick.joy1_y2;
	motor[mBackRight] = joystick.joy1_y2;
}


void test(){
	if(joy1Btn(1)){
		motor[mFrontLeft] = -100;
		motor[mBackLeft] = 100;
		motor[mFrontRight] = 100;
		motor[mBackRight] = -100;
	}
	else{

		motor[mFrontLeft] = 0;
		motor[mBackLeft] = 0;
		motor[mFrontRight] = 0;
		motor[mBackRight] = 0;
	}
}

/**
* Reset motor powers back to zero
*/
void resetDrive()
{
	motor[mFrontLeft] = motor[mBackLeft] = motor[mFrontRight] = motor[mBackRight] = 0;
}

int threshold(int raw)
{
	if (abs(raw) < 25) {
		return 0;
		} else {
		return raw * 100 / 128;
	}
}

void gate(){
	if(joy1Btn(7)){
		servo[sFloodGate] = 5;
	}
	else if(joy1Btn(5)){
		servo[sFloodGate] = 250;
	}
	else{
		servo[sFloodGate] = 127;
	}

}

void intake(){
	if(joy1Btn(11)){
		motor[mIntake] = 100;
	}
	else if(joy1Btn(12)){
		motor[mIntake] = 0;
	}
}

task main(){
	while (true){
		getJoystickSettings(joystick);

						yolodrive(
		threshold(joystick.joy1_y1),
		threshold(joystick.joy1_y2),
		threshold(joystick.joy1_x1),
		threshold(joystick.joy1_x2)
		);
	//	tankdrive();
	  //test();
		intake();
		gate();
	}
}
